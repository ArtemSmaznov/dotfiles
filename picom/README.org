#+title:       Picom
#+author:      Artem Smaznov
#+description: A compositor to prettify the desktop with shadows, transparency, blur and minor animations
#+startup:     overview
#+property:    header-args :tangle ~/.config/picom/picom.conf
#+auto_tangle: t

* Table of Contents :toc:
- [[#dependencies][Dependencies]]
- [[#animations][Animations]]
- [[#corners][Corners]]
- [[#shadows][Shadows]]
- [[#fading][Fading]]
- [[#transparency][Transparency]]
- [[#blur][Blur]]
- [[#general-settings][General Settings]]
- [[#logs][Logs]]
- [[#window-type-settings][Window type settings]]

* Dependencies
|--------------------+------------------------------------------------------------|
| Name               | Description                                                |
|--------------------+------------------------------------------------------------|
| [[https://aur.archlinux.org/packages/picom-jonaburg-git/][picom-jonaburg-git]] | picom compositor fork with animations and dual kawase blur |
|--------------------+------------------------------------------------------------|

#+begin_example shell
paru -S picom-jonaburg-git
#+end_example

* Animations
#+begin_src conf
transition-length = 300
transition-pow-x = 0.1
transition-pow-y = 0.1
transition-pow-w = 0.1
transition-pow-h = 0.1
size-transition = true
#+end_src

* Corners
Sets the radius of rounded window corners. When > 0, the compositor will round the corners of windows. Does not interact well with =transparent-clipping=.
#+begin_src conf
corner-radius = 15.0;
rounded-corners-exclude = [
    "class_g     = 'awesome'",
    "class_g     = 'Polybar'",
    "window_type = 'desktop'",
    "window_type = 'dock'",
    "window_type = 'popup_menu'",
    "window_type = 'notification'",
    "! name~     =''", # exclude windows with no name such as qtile's bar
];

round-borders = 1;
round-borders-exclude = [
  #"class_g = 'TelegramDesktop'",
];
#+end_src

* Shadows
Enabled client-side shadows on windows. Note desktop windows (windows with =_NET_WM_WINDOW_TYPE_DESKTOP=) never get shadow, unless explicitly requested using the =wintypes= option.
#+begin_src conf
shadow = true;

shadow-radius = 12;
shadow-opacity = 0.7;
shadow-offset-x = -12;
shadow-offset-y = -12;

# Specify a list of conditions of windows that should have no shadow.
shadow-exclude = [
    "name    = 'Notification'",
    "class_g = 'Conky'",
    "class_g ?= 'Notify-osd'",
    "class_g = 'Cairo-clock'",
    "class_g = 'slop'",
    "_GTK_FRAME_EXTENTS@:c",
    "_NET_WM_STATE@:32a *= '_NET_WM_STATE_HIDDEN'"
];

# Specify a X geometry that describes the region in which shadow should not
# be painted in, such as a dock window region. Use
#    shadow-exclude-reg = "x10+0+0"
# for example, if the 10 pixels on the bottom of the screen should not have shadows painted on.
#
# shadow-exclude-reg = ""

# Crop shadow of a window fully on a particular Xinerama screen to the screen.
#
# xinerama-shadow-crop = false
#+end_src

* Fading
#+begin_src conf
fading = true;

# Opacity change between steps while fading.
fade-in-step = 0.03;
fade-out-step = 0.03;

# The time between steps in fade step, in milliseconds.
fade-delta = 5;

# Do not fade on window open/close.
#
# no-fading-openclose = true;

# Do not fade destroyed ARGB windows with WM frame. Workaround of bugs in Openbox, Fluxbox, etc.
#
no-fading-destroyed-argb = true;
#+end_src

* Transparency
#+begin_src conf
# Default opacity for active and inactive windows as well as window title bars and borders
#
active-opacity = 1;
frame-opacity = 1;
inactive-opacity = 0.5;
# inactive-dim = 0.0;

# popup_menu = { opacity = 0.8; }
# dropdown_menu = { opacity = 0.8; }

# Let inactive opacity set by -i override the '_NET_WM_OPACITY' values of windows.
#
# inactive-opacity-override = false;

# Specify a list of conditions of windows that should always be considered focused.
#
focus-exclude = [
    "class_g = 'Cairo-clock'",
    "class_g = 'Bar'",                    # lemonbar
    "class_g = 'slop'"                    # maim
];

# Use fixed inactive dim value, instead of adjusting according to window opacity.
#
# inactive-dim-fixed = 1.0

# Specify a list of opacity rules, in the format `PERCENT:PATTERN`,
# like `50:name *= "Firefox"`. picom-trans is recommended over this.
# Note we don't make any guarantee about possible conflicts with other
# programs that set '_NET_WM_WINDOW_OPACITY' on frame or client windows.
#
opacity-rule = [
    "80:class_g = 'URxvt'",
    "80:class_g = 'UXTerm'",
    "80:class_g = 'XTerm'"
];
#+end_src

* Blur
Parameters for background blurring, see the *BLUR* section for more information.
#+begin_src conf
blur: {
  method = "kawase";
  #method = "kernel";
  strength = 7;
  # deviation = 1.0;
  # kernel = "11x11gaussian";
  background = false;
  background-frame = false;
  background-fixed = false;
  kern = "3x3box";
}

# Blur background of semi-transparent / ARGB windows.
# Bad in performance, with driver-dependent behavior.
# The name of the switch may change without prior notifications.
#
blur-background = false;

# Blur background of windows when the window frame is not opaque.
# Implies:
#    blur-background
# Bad in performance, with driver-dependent behavior. The name may change.
#
# blur-background-frame = true;

# Use fixed blur strength rather than adjusting according to window opacity.
#
blur-background-fixed = false;

# Specify the blur convolution kernel, with the following format:
#
# blur-kern = "5,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1";
# blur-kern = "3x3box";

# Exclude conditions for background blur.
#
blur-background-exclude = [
    "window_type = 'desktop'",
    "window_type = 'utility'",
    "class_g     = 'slop'", # for not blurring maim area screenshots
    "_GTK_FRAME_EXTENTS@:c"
];
#+end_src

* General Settings
#+begin_src conf
# Daemonize process. Fork to background after initialization. Causes issues with certain (badly-written) drivers.
#
# daemon = false

# Specify the backend to use: `xrender`, `glx`, or `xr_glx_hybrid`.
# `xrender` is the default one.
#
experimental-backends = true;
backend = "glx";

# Enable/disable VSync.
#
vsync = true;

# Enable remote control via D-Bus. See the *D-BUS API* section below for more details.
#
# dbus = false

# Try to detect WM windows (a non-override-redirect window with no
# child that has 'WM_STATE') and mark them as active.
#
mark-wmwin-focused = true;

# Mark override-redirect windows that doesn't have a child window with 'WM_STATE' focused.
#
mark-ovredir-focused = true;

# Try to detect windows with rounded corners and don't consider them
# shaped windows. The accuracy is not very high, unfortunately.
#
detect-rounded-corners = true;

# Detect '_NET_WM_OPACITY' on client windows, useful for window managers
# not passing '_NET_WM_OPACITY' of client windows to frame windows.
#
detect-client-opacity = true;

# Specify refresh rate of the screen. If not specified or 0, picom will
# try detecting this with X RandR extension.
#
refresh-rate = 0

# Limit picom to repaint at most once every 1 / 'refresh_rate' second to
# boost performance. This should not be used with
#   vsync drm/opengl/opengl-oml
# as they essentially does sw-opti's job already,
# unless you wish to specify a lower refresh rate than the actual value.
#
# sw-opti =

# Use EWMH '_NET_ACTIVE_WINDOW' to determine currently focused window,
# rather than listening to 'FocusIn'/'FocusOut' event. Might have more accuracy,
# provided that the WM supports it.
#
# use-ewmh-active-win = true;

# Unredirect all windows if a full-screen opaque window is detected,
# to maximize performance for full-screen windows. Known to cause flickering
# when redirecting/unredirecting windows.
#
unredir-if-possible = false;

# Delay before unredirecting the window, in milliseconds. Defaults to 0.
#
# unredir-if-possible-delay = 5000;

# Conditions of windows that shouldn't be considered full-screen for unredirecting screen.
#
# unredir-if-possible-exclude = [ ];

# Use 'WM_TRANSIENT_FOR' to group windows, and consider windows
# in the same group focused at the same time.
#
detect-transient = true;

# Use 'WM_CLIENT_LEADER' to group windows, and consider windows in the same
# group focused at the same time. 'WM_TRANSIENT_FOR' has higher priority if
# detect-transient is enabled, too.
#
detect-client-leader = true;

# Resize damaged region by a specific number of pixels.
# A positive value enlarges it while a negative one shrinks it.
# If the value is positive, those additional pixels will not be actually painted
# to screen, only used in blur calculation, and such. (Due to technical limitations,
# with use-damage, those pixels will still be incorrectly painted to screen.)
# Primarily used to fix the line corruption issues of blur,
# in which case you should use the blur radius value here
# (e.g. with a 3x3 kernel, you should use `--resize-damage 1`,
# with a 5x5 one you use `--resize-damage 2`, and so on).
# May or may not work with *--glx-no-stencil*. Shrinking doesn't function correctly.
#
# resize-damage = 1

# Specify a list of conditions of windows that should be painted with inverted color.
# Resource-hogging, and is not well tested.
#
invert-color-include = [ ];

# GLX backend: Avoid using stencil buffer, useful if you don't have a stencil buffer.
# Might cause incorrect opacity when rendering transparent content (but never
# practically happened) and may not work with blur-background.
# My tests show a 15% performance boost. Recommended.
#
glx-no-stencil = true;

# GLX backend: Avoid rebinding pixmap on window damage.
# Probably could improve performance on rapid window content changes,
# but is known to break things on some drivers (LLVMpipe, xf86-video-intel, etc.).
# Recommended if it works.
#
glx-no-rebind-pixmap = true;

# Disable the use of damage information.
# This cause the whole screen to be redrawn everytime, instead of the part of the screen
# has actually changed. Potentially degrades the performance, but might fix some artifacts.
# The opposing option is use-damage
#
use-damage = true;

# Use X Sync fence to sync clients' draw calls, to make sure all draw
# calls are finished before picom starts drawing. Needed on nvidia-drivers
# with GLX backend for some users.
#
xrender-sync-fence = true;

# GLX backend: Use specified GLSL fragment shader for rendering window contents.
# See `compton-default-fshader-win.glsl` and `compton-fake-transparency-fshader-win.glsl`
# in the source tree for examples.
#
# glx-fshader-win = ''

# Force all windows to be painted with blending. Useful if you
# have a glx-fshader-win that could turn opaque pixels transparent.
#
# force-win-blend = false

# Do not use EWMH to detect fullscreen windows.
# Reverts to checking if a window is fullscreen based only on its size and coordinates.
#
# no-ewmh-fullscreen = false

# Dimming bright windows so their brightness doesn't exceed this set value.
# Brightness of a window is estimated by averaging all pixels in the window,
# so this could comes with a performance hit.
# Setting this to 1.0 disables this behaviour. Requires --use-damage to be disabled. (default: 1.0)
#
# max-brightness = 1.0

# Make transparent windows clip other windows like non-transparent windows do,
# instead of blending on top of them.
#
# transparent-clipping = false
#+end_src

* Logs
Set the log level and file
Possible values in increasing level of importance are (case doesn't matter):
 - "trace"
 - "debug"
 - "info"
 - "warn"
 - "error"
If using the "TRACE" log level, it's better to log into a file using *--log-file*, since it can generate a huge stream of logs.

If *--log-file* is never specified, logs will be written to =stderr=.
Otherwise, logs will to written to the given file, though some of the early logs might still be written to the =stderr=.
When setting this option from the config file, it is recommended to use an absolute path.

#+begin_src conf
log-level = "error";
# log-file = "~/.cache/picom.log";

# Show all X errors (for debugging)
#
# show-all-xerrors = false

# Write process ID to a file.
#
# write-pid-path = "~/.cache/picom_pid.log"
#+end_src

* Window type settings
'WINDOW_TYPE' is one of the 15 window types defined in EWMH standard:
  - =unknown=
  - =desktop=
  - =dock=
  - =toolbar=
  - =menu=
  - =utility=
  - =splash=
  - =dialog=
  - =normal=
  - =dropdown_menu=
  - =popup_menu=
  - =tooltip=
  - =notification=
  - =combo=
  - =dnd=

Following per window-type options are available:
  - =fade=, =shadow=
    Controls window-type-specific shadow and fade settings.
  - =opacity=
    Controls default opacity of the window type.
  - =focus=
    Controls whether the window of this type is to be always considered focused.
    (By default, all window types except "normal" and "dialog" has this on.)
  - =full-shadow=
    Controls whether shadow is drawn under the parts of the window that you normally won't be able to see. Useful when the window has parts of it transparent, and you want shadows in those areas.
  - =clip-shadow-above=
    Controls whether shadows that would have been drawn above the window should be clipped. Useful for dock windows that should have no shadow painted on top.
  - =redir-ignore=
    Controls whether this type of windows should cause screen to become redirected again after been un-redirected. If you have =unredir-if-possible= set, and doesn't want certain window to cause unnecessary screen redirection, you can set this to =true=.

#+begin_src conf
wintypes:
{
    normal        = { shadow = false;                               };
    tooltip       = { shadow = true;  focus = false; fade = true;   };
    dock          = { shadow = true;                                };
    dnd           = { shadow = false;                               };
    popup_menu    = { shadow = true;  focus = false; opacity = 0.8; };
    dropdown_menu = { shadow = false; focus = false;                };
    above         = { shadow = true;                                };
    splash        = { shadow = false;                               };
    utility       = { shadow = false; focus = false;                };
    notification  = { shadow = true;                                };
    desktop       = { shadow = false                                };
    menu          = { focus  = false                                };
    dialog        = { shadow = true;                                };
                                                                    };
#+end_src

